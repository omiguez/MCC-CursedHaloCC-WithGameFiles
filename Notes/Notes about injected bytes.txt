0x56, 0x48, 0x81, 0xC6, 0x9C, 0x00, 0x00, 0x00, 
0x48, 0x8B, 0xF6, 0x90, 0x90, 0x90, 0x90, 
0xF3, 0x0F, 0x10, 0x96, 0x9C, 0x00, 0x00, 0x00

Example of jump done with the InjectASMSimple  instruction:
Destination: 2CD28EE0001 - 48 81 C6 9C000000     - add rsi,0000009C
Source: 7FF8B81B0BBA - 68 0000EE28           - push 28EE0000
Difference: To - From: 
Oh yes, it's doing an absolute position pushing and then using ret.

Injected bytes: 5 + 8 + 1 = 14 (o E en hex)
Overwritten Instructions: 7 + 3 + 4 = E In this case it is a coincidence, I tried it with other instructions and it breaks them. Just know that 14 bytes are forfeit.

There's several options for mov https://www.felixcloutier.com/x86/mov
For instance, for mov [2CD36C10000],rax, the bytes are
48 A3 00 00 C1 36 CD 02 00 00
48 is rex, A3 the op code, the rest is the operand. the A3 OpCode always moves from RAX, so there's no need to set it.
Others I think require an address difference, which is pain.

56 // push rsi
48 81 C6 9C 00 00 00 //add rsi,0000009C
48 A3 00 00 C1 36 CD 02 00 00 // mov [2CD36C10000],rax
mov [2CD36C10000],rax
push rax: 1b
mov rax, rsi: 3b
add rax,0000009C: 6b
mov [2CD36C10000],rax: 10 bytes. 00 00 C1 36 CD 02 00 00 is the operand as little endian, 8 bytes with padding
pop: 1 byte
All together:
50 48 8B C6 48 05 9C 00 00 00 48 A3 00 00 C1 36 CD 02 00 00 58 
Separated:
50
48 8B C6 
48 05 9C 00 00 00
48 A3 00 00 C1 36 CD 02 00 00
58

And then the mov and ret to jump to 7FF87FF8B81B0C07. (remember, bytes are in little)
2CD36C20017 - 68 070C1BB8           - push FFFFFFFFB81B0C07
2CD36C2001C - C7 44 24 04 F87F0000  - mov [rsp+04],00007FF8

----
7FF8584BE7C8 maybe death function? Doesn't look like it.

7FF8584BFDFB  remove this and health won't go down. Right next to the first entry that triggers on damage. FOR EVERYONE INCLUDING ENEMIES. 

5BCB9F890 - 44 has a 0

Cuando te haces da√±o, algo salta a 7FF8584BEF9A - 41 B9 01000000        - mov r9d,00000001
