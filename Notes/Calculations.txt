Bytes of the injection (including the jmp, which is the E9 42 05 c7 00)
56,  48 81 C6 9C 00 00 00, 48 89 35 F1 FF 00 00, 5E,  F3 0F 10 96 9C 00 00 00, E9 42 05 C7 00

In the code cave:
Jump back to : 7FF8C884055F
Jumping from: 7FF8C7BD0018
Next instruction from jump point: 7FF8C7BD001D . This is where it actually jumps from.
Bytes: E9 42 05 C7 00  <- the hex is reversed. For instance, this is 00 C7 05 42
To - From: C7 0547
From - To: FFFF FFFF FF38 FABE

In the injection point:
Now, about the jump to the cave:
Jump to: 7FF8C7BD0000 
Jump from (this is the next instruction after jmp): 7FF8C884055C 
Bytes: E9 A4 FA 38 FF <- FF 38 FA A4, matches to - from
To - from: FFFF FFFF FF38 FAA4
From - To: C7 055C

So, what you need to do is: Absolute address to jump to - absolute address of the instruction next to the jmp, take the last 4 bytes, and then reverse the array (its little endian).

Let's try a simpler version that does not use an address.
These are the bytes of that: 
56, 48 81 C6 9C 00 00 00, 
48 8B F6, 90, 90, 90, 90, 
F3 0F 10 96 9C 00 00 00
+ the jump (E9 + the bytes as determined above)

This code should do nothing, but if it does the replacement without a crash, we're golden.